/* --------------------------------------------------------------------------------------------
 * Copyright (c) Remy Suen. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_1 = require("vscode-languageserver");
const dockerfile_utils_1 = require("dockerfile-utils");
const dockerAssist_1 = require("./dockerAssist");
const dockerCommands_1 = require("./dockerCommands");
const dockerHover_1 = require("./dockerHover");
const dockerMarkdown_1 = require("./dockerMarkdown");
const dockerPlainText_1 = require("./dockerPlainText");
const dockerSignatures_1 = require("./dockerSignatures");
const dockerSymbols_1 = require("./dockerSymbols");
const dockerFormatter_1 = require("./dockerFormatter");
const dockerHighlight_1 = require("./dockerHighlight");
const dockerRename_1 = require("./dockerRename");
const dockerDefinition_1 = require("./dockerDefinition");
const dockerRegistryClient_1 = require("./dockerRegistryClient");
let markdown = new dockerMarkdown_1.MarkdownDocumentation();
let hoverProvider = new dockerHover_1.DockerHover(markdown);
let commandsProvider = new dockerCommands_1.DockerCommands();
let symbolsProvider = new dockerSymbols_1.DockerSymbols();
let formatterProvider = new dockerFormatter_1.DockerFormatter();
let definitionProvider = new dockerDefinition_1.DockerDefinition();
let documentationResolver = new dockerPlainText_1.PlainTextDocumentation();
let signatureHelp = new dockerSignatures_1.DockerSignatures();
/**
 * The settings to use for the validator if the client doesn't support
 * workspace/configuration requests.
 */
let validatorSettings = null;
/**
 * The validator settings that correspond to an individual file retrieved via
 * the workspace/configuration request.
 */
let validatorConfigurations = new Map();
let connection = vscode_languageserver_1.createConnection(vscode_languageserver_1.ProposedFeatures.all);
let dockerRegistryClient = new dockerRegistryClient_1.DockerRegistryClient(connection);
let snippetSupport = false;
/**
 * Whether the client supports the workspace/applyEdit request.
 */
let applyEditSupport = false;
/**
 * Whether the client supports the workspace/configuration request.
 */
let configurationSupport = false;
let documents = {};
function supportsSnippets(capabilities) {
    return capabilities.textDocument
        && capabilities.textDocument.completion
        && capabilities.textDocument.completion.completionItem
        && capabilities.textDocument.completion.completionItem.snippetSupport;
}
connection.onInitialized(() => {
    if (configurationSupport) {
        // listen for notification changes if the client supports workspace/configuration
        connection.client.register(vscode_languageserver_1.DidChangeConfigurationNotification.type);
    }
});
connection.onInitialize((params) => {
    snippetSupport = supportsSnippets(params.capabilities);
    applyEditSupport = params.capabilities.workspace && params.capabilities.workspace.applyEdit === true;
    configurationSupport = params.capabilities.workspace && params.capabilities.workspace.configuration === true;
    return {
        capabilities: {
            textDocumentSync: vscode_languageserver_1.TextDocumentSyncKind.Incremental,
            codeActionProvider: applyEditSupport,
            completionProvider: {
                resolveProvider: true,
                triggerCharacters: [
                    '=',
                    ' ',
                    '$',
                    '-',
                ]
            },
            executeCommandProvider: applyEditSupport ? {
                commands: [
                    dockerCommands_1.CommandIds.LOWERCASE,
                    dockerCommands_1.CommandIds.UPPERCASE,
                    dockerCommands_1.CommandIds.EXTRA_ARGUMENT,
                    dockerCommands_1.CommandIds.DIRECTIVE_TO_BACKSLASH,
                    dockerCommands_1.CommandIds.DIRECTIVE_TO_BACKTICK,
                    dockerCommands_1.CommandIds.FLAG_TO_CHOWN,
                    dockerCommands_1.CommandIds.FLAG_TO_COPY_FROM,
                    dockerCommands_1.CommandIds.FLAG_TO_HEALTHCHECK_INTERVAL,
                    dockerCommands_1.CommandIds.FLAG_TO_HEALTHCHECK_RETRIES,
                    dockerCommands_1.CommandIds.FLAG_TO_HEALTHCHECK_START_PERIOD,
                    dockerCommands_1.CommandIds.FLAG_TO_HEALTHCHECK_TIMEOUT,
                    dockerCommands_1.CommandIds.CONVERT_TO_AS
                ]
            } : undefined,
            documentFormattingProvider: true,
            documentRangeFormattingProvider: true,
            documentOnTypeFormattingProvider: {
                firstTriggerCharacter: '\\',
                moreTriggerCharacter: ['`']
            },
            hoverProvider: true,
            documentSymbolProvider: true,
            documentHighlightProvider: true,
            renameProvider: true,
            definitionProvider: true,
            signatureHelpProvider: {
                triggerCharacters: [
                    '-',
                    '[',
                    ',',
                    ' ',
                    '='
                ]
            }
        }
    };
});
function validateTextDocument(textDocument) {
    if (configurationSupport) {
        getConfiguration(textDocument.uri).then((config) => {
            let maintainer = dockerfile_utils_1.ValidationSeverity.WARNING;
            let directiveCasing = dockerfile_utils_1.ValidationSeverity.WARNING;
            let emptyContinuationLine = dockerfile_utils_1.ValidationSeverity.WARNING;
            let instructionCasing = dockerfile_utils_1.ValidationSeverity.WARNING;
            let instructionCmdMultiple = dockerfile_utils_1.ValidationSeverity.WARNING;
            let instructionEntrypointMultiple = dockerfile_utils_1.ValidationSeverity.WARNING;
            let instructionHealthcheckMultiple = dockerfile_utils_1.ValidationSeverity.WARNING;
            if (config) {
                maintainer = getSeverity(config.deprecatedMaintainer);
                directiveCasing = getSeverity(config.directiveCasing);
                emptyContinuationLine = getSeverity(config.emptyContinuationLine);
                instructionCasing = getSeverity(config.instructionCasing);
                instructionCmdMultiple = getSeverity(config.instructionCmdMultiple);
                instructionEntrypointMultiple = getSeverity(config.instructionEntrypointMultiple);
                instructionHealthcheckMultiple = getSeverity(config.instructionHealthcheckMultiple);
            }
            const fileSettings = {
                deprecatedMaintainer: maintainer,
                directiveCasing: directiveCasing,
                emptyContinuationLine: emptyContinuationLine,
                instructionCasing: instructionCasing,
                instructionCmdMultiple: instructionCmdMultiple,
                instructionEntrypointMultiple: instructionEntrypointMultiple,
                instructionHealthcheckMultiple: instructionHealthcheckMultiple
            };
            const diagnostics = dockerfile_utils_1.validate(textDocument.getText(), fileSettings);
            connection.sendDiagnostics({ uri: textDocument.uri, diagnostics });
        });
    }
    else {
        const diagnostics = dockerfile_utils_1.validate(textDocument.getText(), validatorSettings);
        connection.sendDiagnostics({ uri: textDocument.uri, diagnostics });
    }
}
function getSeverity(severity) {
    switch (severity) {
        case "ignore":
            return dockerfile_utils_1.ValidationSeverity.IGNORE;
        case "warning":
            return dockerfile_utils_1.ValidationSeverity.WARNING;
        case "error":
            return dockerfile_utils_1.ValidationSeverity.ERROR;
    }
    return null;
}
/**
 * Gets the validation configuration that pertains to the specified resource.
 *
 * @param resource the interested resource
 * @return the configuration to use to validate the interested resource
 */
function getConfiguration(resource) {
    let result = validatorConfigurations.get(resource);
    if (!result) {
        result = connection.workspace.getConfiguration({ section: "docker.languageserver.diagnostics", scopeUri: resource });
        validatorConfigurations.set(resource, result);
    }
    return result;
}
// listen for notifications when the client's configuration has changed
connection.onNotification(vscode_languageserver_1.DidChangeConfigurationNotification.type, () => {
    refreshConfigurations();
});
/**
 * Wipes and reloads the internal cache of validator configurations.
 */
function refreshConfigurations() {
    // store all the URIs that need to be refreshed
    const settingsRequest = [];
    for (let uri in documents) {
        settingsRequest.push({ section: "docker.languageserver.diagnostics", scopeUri: uri });
    }
    // clear the cache
    validatorConfigurations.clear();
    // ask the workspace for the configurations
    connection.workspace.getConfiguration(settingsRequest).then((values) => {
        const toRevalidate = [];
        for (let i = 0; i < values.length; i++) {
            const resource = settingsRequest[i].scopeUri;
            // a value might have been stored already, use it instead and ignore this one if so
            if (values[i] && !validatorConfigurations.has(resource)) {
                validatorConfigurations.set(resource, Promise.resolve(values[i]));
                toRevalidate.push(resource);
            }
        }
        for (const resource of toRevalidate) {
            validateTextDocument(documents[resource]);
        }
    });
}
connection.onDidChangeConfiguration((change) => {
    if (configurationSupport) {
        refreshConfigurations();
    }
    else {
        let settings = change.settings;
        let maintainer = dockerfile_utils_1.ValidationSeverity.WARNING;
        let directiveCasing = dockerfile_utils_1.ValidationSeverity.WARNING;
        let emptyContinuationLine = dockerfile_utils_1.ValidationSeverity.WARNING;
        let instructionCasing = dockerfile_utils_1.ValidationSeverity.WARNING;
        let instructionCmdMultiple = dockerfile_utils_1.ValidationSeverity.WARNING;
        let instructionEntrypointMultiple = dockerfile_utils_1.ValidationSeverity.WARNING;
        let instructionHealthcheckMultiple = dockerfile_utils_1.ValidationSeverity.WARNING;
        if (settings.docker && settings.docker.languageserver && settings.docker.languageserver.diagnostics) {
            maintainer = getSeverity(settings.docker.languageserver.diagnostics.deprecatedMaintainer);
            directiveCasing = getSeverity(settings.docker.languageserver.diagnostics.directiveCasing);
            emptyContinuationLine = getSeverity(settings.docker.languageserver.diagnostics.emptyContinuationLine);
            instructionCasing = getSeverity(settings.docker.languageserver.diagnostics.instructionCasing);
            instructionCmdMultiple = getSeverity(settings.docker.languageserver.diagnostics.instructionCmdMultiple);
            instructionEntrypointMultiple = getSeverity(settings.docker.languageserver.diagnostics.instructionEntrypointMultiple);
            instructionHealthcheckMultiple = getSeverity(settings.docker.languageserver.diagnostics.instructionHealthcheckMultiple);
        }
        validatorSettings = {
            deprecatedMaintainer: maintainer,
            directiveCasing: directiveCasing,
            emptyContinuationLine: emptyContinuationLine,
            instructionCasing: instructionCasing,
            instructionCmdMultiple: instructionCmdMultiple,
            instructionEntrypointMultiple: instructionEntrypointMultiple,
            instructionHealthcheckMultiple: instructionHealthcheckMultiple
        };
        // validate all the documents again
        Object.keys(documents).forEach((key) => {
            validateTextDocument(documents[key]);
        });
    }
});
connection.onCompletion((textDocumentPosition) => {
    let document = documents[textDocumentPosition.textDocument.uri];
    if (document) {
        let assist = new dockerAssist_1.DockerAssist(document, snippetSupport, dockerRegistryClient);
        return assist.computeProposals(document, textDocumentPosition.position);
    }
    return null;
});
connection.onSignatureHelp((textDocumentPosition) => {
    let document = documents[textDocumentPosition.textDocument.uri];
    if (document !== null) {
        return signatureHelp.computeSignatures(document, textDocumentPosition.position);
    }
    return {
        signatures: [],
        activeSignature: null,
        activeParameter: null,
    };
});
connection.onCompletionResolve((item) => {
    if (!item.documentation) {
        item.documentation = documentationResolver.getDocumentation(item.data);
    }
    return item;
});
connection.onHover((textDocumentPosition) => {
    let document = documents[textDocumentPosition.textDocument.uri];
    if (document !== null) {
        return hoverProvider.onHover(document, textDocumentPosition);
    }
    return null;
});
connection.onDocumentHighlight((textDocumentPosition) => {
    let document = documents[textDocumentPosition.textDocument.uri];
    if (document) {
        let highlightProvider = new dockerHighlight_1.DockerHighlight();
        return highlightProvider.computeHighlightRanges(document, textDocumentPosition.position);
    }
    return [];
});
connection.onCodeAction((codeActionParams) => {
    if (applyEditSupport && codeActionParams.context.diagnostics.length > 0) {
        return commandsProvider.analyzeDiagnostics(codeActionParams.context.diagnostics, codeActionParams.textDocument.uri);
    }
    return [];
});
connection.onExecuteCommand((params) => {
    if (applyEditSupport) {
        let uri = params.arguments[0];
        let document = documents[uri];
        if (document) {
            let edit = commandsProvider.createWorkspaceEdit(document, params);
            if (edit) {
                connection.workspace.applyEdit(edit);
            }
        }
    }
});
connection.onDefinition((textDocumentPosition) => {
    let uri = textDocumentPosition.textDocument.uri;
    let document = documents[uri];
    if (document) {
        return definitionProvider.computeDefinition(document, textDocumentPosition.position);
    }
    return null;
});
connection.onRenameRequest((params) => {
    let document = documents[params.textDocument.uri];
    if (document) {
        let rename = new dockerRename_1.DockerRename();
        let edits = rename.rename(document, params.position, params.newName);
        return {
            changes: {
                [params.textDocument.uri]: edits
            }
        };
    }
    return null;
});
connection.onDocumentSymbol((documentSymbolParams) => {
    let uri = documentSymbolParams.textDocument.uri;
    let document = documents[uri];
    if (document) {
        return symbolsProvider.parseSymbolInformation(document, uri);
    }
    return [];
});
connection.onDocumentFormatting((documentFormattingParams) => {
    let document = documents[documentFormattingParams.textDocument.uri];
    if (document) {
        return dockerfile_utils_1.format(document.getText(), documentFormattingParams.options);
    }
    return [];
});
connection.onDocumentRangeFormatting((rangeFormattingParams) => {
    let document = documents[rangeFormattingParams.textDocument.uri];
    if (document) {
        return formatterProvider.formatRange(document, rangeFormattingParams.range, rangeFormattingParams.options);
    }
    return [];
});
connection.onDocumentOnTypeFormatting((onTypeFormattingParams) => {
    const document = documents[onTypeFormattingParams.textDocument.uri];
    if (document) {
        return formatterProvider.formatOnType(document, onTypeFormattingParams.position, onTypeFormattingParams.ch, onTypeFormattingParams.options);
    }
    return [];
});
connection.onDidOpenTextDocument((didOpenTextDocumentParams) => {
    let document = vscode_languageserver_1.TextDocument.create(didOpenTextDocumentParams.textDocument.uri, didOpenTextDocumentParams.textDocument.languageId, didOpenTextDocumentParams.textDocument.version, didOpenTextDocumentParams.textDocument.text);
    documents[didOpenTextDocumentParams.textDocument.uri] = document;
    validateTextDocument(document);
});
function getLaterChange(changes, i, j) {
    if (changes[i].range.start.line === changes[j].range.start.line) {
        return changes[i].range.start.character < changes[j].range.start.character ? j : i;
    }
    else if (changes[i].range.start.line < changes[j].range.start.line) {
        return j;
    }
    return i;
}
function sortChanges(changes) {
    let sorted = [];
    let length = changes.length;
    for (let i = 0; i < length; i++) {
        let candidate = 0;
        for (let j = 1; j < changes.length; j++) {
            candidate = getLaterChange(changes, candidate, j);
        }
        sorted.push(changes[candidate]);
        changes.splice(candidate, 1);
    }
    return sorted;
}
function handleChanges(document, content, changes) {
    if (changes.length === 1 && !changes[0].range) {
        // not an incremental change
        return changes[0].text;
    }
    else if (changes.length !== 0) {
        changes = sortChanges(changes);
        for (let i = 0; i < changes.length; i++) {
            let offset = document.offsetAt(changes[i].range.start);
            let end = null;
            if (changes[i].range.end) {
                end = document.offsetAt(changes[i].range.end);
            }
            else {
                end = offset + changes[i].rangeLength;
            }
            content = content.substring(0, offset) + changes[i].text + content.substring(end);
        }
    }
    return content;
}
connection.onDidChangeTextDocument((didChangeTextDocumentParams) => {
    let document = documents[didChangeTextDocumentParams.textDocument.uri];
    let buffer = document.getText();
    let changes = didChangeTextDocumentParams.contentChanges;
    let changed = handleChanges(document, buffer, changes);
    if (changed !== buffer) {
        document = vscode_languageserver_1.TextDocument.create(didChangeTextDocumentParams.textDocument.uri, document.languageId, didChangeTextDocumentParams.textDocument.version, changed);
        documents[didChangeTextDocumentParams.textDocument.uri] = document;
        validateTextDocument(document);
    }
});
connection.onDidCloseTextDocument((didCloseTextDocumentParams) => {
    validatorConfigurations.delete(didCloseTextDocumentParams.textDocument.uri);
    delete documents[didCloseTextDocumentParams.textDocument.uri];
});
// setup complete, start listening for a client connection
connection.listen();
