/* --------------------------------------------------------------------------------------------
 * Copyright (c) Remy Suen. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const dockerfile_ast_1 = require("dockerfile-ast");
const docker_1 = require("./docker");
const dockerDefinition_1 = require("./dockerDefinition");
class DockerHover {
    constructor(markdown) {
        this.markdown = markdown;
    }
    onHover(document, textDocumentPosition) {
        let dockerfile = dockerfile_ast_1.DockerfileParser.parse(document.getText());
        let directive = dockerfile.getDirective();
        let image = dockerfile.getContainingImage(textDocumentPosition.position);
        if (textDocumentPosition.position.line === 0 && directive !== null && directive.getDirective() === dockerfile_ast_1.Directive.escape) {
            let range = directive.getNameRange();
            if (docker_1.Util.isInsideRange(textDocumentPosition.position, range)) {
                return this.markdown.getMarkdown(dockerfile_ast_1.Directive.escape);
            }
        }
        for (let instruction of image.getInstructions()) {
            for (let variable of instruction.getVariables()) {
                // are we hovering over a variable
                if (docker_1.Util.isInsideRange(textDocumentPosition.position, variable.getNameRange())) {
                    let instructions = image.getInstructions();
                    for (let i = instructions.length - 1; i >= 0; i--) {
                        // only look for variables defined before the current instruction
                        if (instruction.isAfter(instructions[i]) && instructions[i] instanceof dockerfile_ast_1.Env) {
                            for (let property of instructions[i].getProperties()) {
                                // check that the names match
                                if (property.getName() === variable.getName()) {
                                    return property.getValue() !== null ? { contents: property.getValue() } : null;
                                }
                            }
                        }
                    }
                }
            }
        }
        for (let instruction of image.getInstructions()) {
            let instructionRange = instruction.getInstructionRange();
            if (docker_1.Util.isInsideRange(textDocumentPosition.position, instructionRange)) {
                return this.markdown.getMarkdown(instruction.getKeyword());
            }
            if (instruction instanceof dockerfile_ast_1.Onbuild) {
                // hovering over a trigger instruction of an ONBUILD
                let range = instruction.getTriggerRange();
                if (docker_1.Util.isInsideRange(textDocumentPosition.position, range)) {
                    return this.markdown.getMarkdown(instruction.getTrigger());
                }
            }
            if (instruction instanceof dockerfile_ast_1.Arg) {
                // hovering over an argument defined by ARG
                let property = instruction.getProperty();
                if (property && docker_1.Util.isInsideRange(textDocumentPosition.position, property.getNameRange()) && property.getValue() !== null) {
                    return {
                        contents: property.getValue()
                    };
                }
            }
            if (instruction instanceof dockerfile_ast_1.Env) {
                // hovering over an argument defined by ENV
                for (let property of instruction.getProperties()) {
                    if (docker_1.Util.isInsideRange(textDocumentPosition.position, property.getNameRange()) && property.getValue() !== null) {
                        return {
                            contents: property.getValue()
                        };
                    }
                }
            }
            let hover = this.getFlagsHover(textDocumentPosition.position, instruction);
            if (hover !== undefined) {
                return hover;
            }
        }
        let property = dockerDefinition_1.DockerDefinition.findDefinition(dockerfile, textDocumentPosition.position);
        if (property && property.getValue() !== null) {
            return { contents: property.getValue() };
        }
        return null;
    }
    getFlagsHover(position, instruction) {
        switch (instruction.getKeyword()) {
            case "ADD":
                let addFlags = instruction.getFlags();
                for (let flag of addFlags) {
                    if (docker_1.Util.isInsideRange(position, flag.getNameRange())) {
                        switch (flag.getName()) {
                            case "chown":
                                return this.markdown.getMarkdown("ADD_FlagChown");
                        }
                    }
                }
                break;
            case "COPY":
                let copyFlags = instruction.getFlags();
                for (let flag of copyFlags) {
                    if (docker_1.Util.isInsideRange(position, flag.getNameRange())) {
                        switch (flag.getName()) {
                            case "chown":
                                return this.markdown.getMarkdown("COPY_FlagChown");
                            case "from":
                                return this.markdown.getMarkdown("COPY_FlagFrom");
                        }
                    }
                }
                break;
            case "HEALTHCHECK":
                let flags = instruction.getFlags();
                for (let flag of flags) {
                    if (docker_1.Util.isInsideRange(position, flag.getNameRange())) {
                        switch (flag.getName()) {
                            case "interval":
                                return this.markdown.getMarkdown("HEALTHCHECK_FlagInterval");
                            case "retries":
                                return this.markdown.getMarkdown("HEALTHCHECK_FlagRetries");
                            case "start-period":
                                return this.markdown.getMarkdown("HEALTHCHECK_FlagStartPeriod");
                            case "timeout":
                                return this.markdown.getMarkdown("HEALTHCHECK_FlagTimeout");
                        }
                        return null;
                    }
                }
                break;
            case "ONBUILD":
                let trigger = instruction.getTriggerInstruction();
                if (trigger !== null) {
                    return this.getFlagsHover(position, trigger);
                }
                break;
        }
        return undefined;
    }
}
exports.DockerHover = DockerHover;
