/* --------------------------------------------------------------------------------------------
 * Copyright (c) Remy Suen. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_1 = require("vscode-languageserver");
const docker_1 = require("./docker");
const dockerfile_ast_1 = require("dockerfile-ast");
class DockerAssist {
    /**
     * Creates a content assist processor for suggesting completion items related to a Dockerfile.
     *
     * @param document the text document to provide suggestions for
     * @param snippetSupport true if snippets are supported by the client, false otherwise
     * @param dockerRegistryClient the client for communicating with a Docker registry
     */
    constructor(document, snippetSupport, dockerRegistryClient) {
        this.document = document;
        this.snippetSupport = snippetSupport;
        this.dockerRegistryClient = dockerRegistryClient;
    }
    computeProposals(document, position) {
        let buffer = document.getText();
        let offset = document.offsetAt(position);
        let dockerfile = dockerfile_ast_1.DockerfileParser.parse(buffer);
        let escapeCharacter = dockerfile.getEscapeCharacter();
        let directive = dockerfile.getDirective();
        if (directive !== null && position.line === 0) {
            let range = directive.getNameRange();
            if (position.character <= range.start.character) {
                // in whitespace before the directive's name
                return [this.createEscape(0, offset, dockerfile_ast_1.Directive.escape)];
            }
            else if (position.character <= range.end.character) {
                // in the name
                return [this.createEscape(position.character - range.start.character, offset, dockerfile_ast_1.Directive.escape)];
            }
            return [];
        }
        // directive only possible on the first line
        let comments = dockerfile.getComments();
        if (comments.length !== 0) {
            if (position.line === 0) {
                let commentRange = comments[0].getRange();
                // check if the first comment is on the first line
                if (commentRange.start.line === 0) {
                    // is the user inside the comment
                    if (commentRange.start.character < position.character) {
                        let range = comments[0].getContentRange();
                        if (range === null || position.character <= range.start.character) {
                            // in whitespace
                            return [this.createEscape(0, offset, dockerfile_ast_1.Directive.escape)];
                        }
                        let comment = comments[0].getContent();
                        if (position.character <= range.end.character) {
                            // within the content
                            let prefix = comment.substring(0, position.character - range.start.character);
                            // substring check
                            if (dockerfile_ast_1.Directive.escape.indexOf(prefix.toLowerCase()) === 0) {
                                return [this.createEscape(prefix.length, offset, dockerfile_ast_1.Directive.escape)];
                            }
                        }
                        return [];
                    }
                }
            }
            else {
                for (let comment of comments) {
                    let range = comment.getRange();
                    if (range.start.line === position.line) {
                        if (range.start.character < position.character && position.character <= range.end.character) {
                            // inside a comment
                            return [];
                        }
                    }
                }
            }
        }
        let prefix = DockerAssist.calculateTruePrefix(buffer, offset, escapeCharacter);
        if (prefix !== "") {
            let index = prefix.lastIndexOf('$');
            // $ exists so we're at a variable
            if (index !== -1) {
                // check that the variable $ wasn't escaped
                if (prefix.charAt(index - 1) !== '\\') {
                    // get the variable's prefix thus far
                    var variablePrefix = prefix.substring(index + 1).toLowerCase();
                    let prefixLength = variablePrefix.length + 1;
                    const items = [];
                    if (variablePrefix === "") {
                        // empty prefix, return all variables
                        for (let variable of dockerfile.getAvailableVariables(position.line)) {
                            let doc = dockerfile.resolveVariable(variable, position.line);
                            items.push(this.createVariableCompletionItem(variable, prefixLength, offset, true, doc));
                        }
                        for (let variable of dockerfile_ast_1.DefaultVariables) {
                            let doc = dockerfile.resolveVariable(variable, position.line);
                            items.push(this.createVariableCompletionItem(variable, prefixLength, offset, true, doc));
                        }
                    }
                    else {
                        let brace = false;
                        if (variablePrefix.charAt(0) === '{') {
                            brace = true;
                            variablePrefix = variablePrefix.substring(1);
                        }
                        for (let variable of dockerfile.getAvailableVariables(position.line)) {
                            if (variable.toLowerCase().indexOf(variablePrefix) === 0) {
                                let doc = dockerfile.resolveVariable(variable, position.line);
                                items.push(this.createVariableCompletionItem(variable, prefixLength, offset, brace, doc));
                            }
                        }
                        for (let variable of dockerfile_ast_1.DefaultVariables) {
                            if (variable.toLowerCase().indexOf(variablePrefix) === 0) {
                                let doc = dockerfile.resolveVariable(variable, position.line);
                                items.push(this.createVariableCompletionItem(variable, prefixLength, offset, brace, doc));
                            }
                        }
                    }
                    items.sort((a, b) => {
                        if (a.label.toLowerCase() === b.label.toLowerCase()) {
                            // put uppercase variables first
                            return a.label.localeCompare(b.label) * -1;
                        }
                        return a.label.localeCompare(b.label);
                    });
                    return items;
                }
            }
        }
        let previousWord = "";
        instructionsCheck: for (let instruction of dockerfile.getInstructions()) {
            if (docker_1.Util.isInsideRange(position, instruction.getInstructionRange())) {
                break;
            }
            else if (docker_1.Util.isInsideRange(position, instruction.getRange())) {
                switch (instruction.getKeyword()) {
                    case "ADD":
                        return this.createAddProposals(instruction, position, offset, prefix);
                    case "COPY":
                        return this.createCopyProposals(dockerfile, instruction, position, offset, prefix);
                    case "FROM":
                        return this.createFromProposals(instruction, position, prefix);
                    case "HEALTHCHECK":
                        let subcommand = instruction.getSubcommand();
                        if (subcommand && subcommand.isBefore(position)) {
                            return [];
                        }
                        return this.createHealthcheckProposals(offset, prefix);
                    case "ONBUILD":
                        let onbuildArgs = instruction.getArguments();
                        if (onbuildArgs.length === 0 || docker_1.Util.isInsideRange(position, onbuildArgs[0].getRange())) {
                            // no trigger instructions or the cursor is in the trigger instruction
                            previousWord = "ONBUILD";
                            break instructionsCheck;
                        }
                        else {
                            let trigger = instruction.getTriggerInstruction();
                            switch (trigger.getKeyword()) {
                                case "ADD":
                                    return this.createAddProposals(trigger, position, offset, prefix);
                                case "COPY":
                                    return this.createCopyProposals(dockerfile, trigger, position, offset, prefix);
                                case "HEALTHCHECK":
                                    let subcommand = trigger.getSubcommand();
                                    if (subcommand && subcommand.isBefore(position)) {
                                        return [];
                                    }
                                    return this.createHealthcheckProposals(offset, prefix);
                            }
                        }
                        return [];
                    default:
                        return [];
                }
            }
        }
        if (prefix === "") {
            if (dockerfile.getInstructions().length === 0) {
                // if we don't have any instructions, only suggest FROM
                return [this.createFROM(0, offset, "FROM")];
            }
            // no prefix, return all the proposals
            return this.createProposals(docker_1.KEYWORDS, previousWord, 0, offset);
        }
        const suggestions = [];
        var uppercasePrefix = prefix.toUpperCase();
        for (let i = 0; i < docker_1.KEYWORDS.length; i++) {
            if (docker_1.KEYWORDS[i] === uppercasePrefix) {
                // prefix is a keyword already, nothing to suggest
                return [];
            }
            else if (docker_1.KEYWORDS[i].indexOf(uppercasePrefix) === 0) {
                suggestions.push(docker_1.KEYWORDS[i]);
            }
        }
        if (suggestions.length === 0) {
            // prefix doesn't match any keywords, nothing to suggest
            return [];
        }
        return this.createProposals(suggestions, previousWord, prefix.length, offset);
    }
    createProposals(keywords, previousWord, prefixLength, offset) {
        let proposals = [];
        for (var i = 0; i < keywords.length; i++) {
            switch (keywords[i]) {
                case "ARG":
                    if (this.snippetSupport) {
                        proposals.push(this.createARG_NameOnly(prefixLength, offset));
                        proposals.push(this.createARG_DefaultValue(prefixLength, offset));
                    }
                    else {
                        proposals.push(this.createARG(prefixLength, offset));
                    }
                    break;
                case "HEALTHCHECK":
                    proposals.push(this.createHEALTHCHECK_CMD(prefixLength, offset));
                    proposals.push(this.createHEALTHCHECK_NONE(prefixLength, offset));
                    break;
                case "FROM":
                case "MAINTAINER":
                case "ONBUILD":
                    // can't have FROM, MAINTAINER, or ONBUILD follow an ONBUILD
                    if (previousWord) {
                        break;
                    }
                default:
                    proposals.push(this.createSingleProposals(keywords[i], prefixLength, offset));
                    break;
            }
        }
        return proposals;
    }
    createAddProposals(add, position, offset, prefix) {
        const flags = add.getFlags();
        let copyArgs = add.getArguments();
        if (copyArgs.length === 0 && add.getFlags().length === 0) {
            return [this.createADD_FlagChown(0, offset)];
        }
        else if (copyArgs.length > 0 && docker_1.Util.isInsideRange(position, copyArgs[0].getRange()) && prefix === "-") {
            return [this.createADD_FlagChown(prefix.length, offset)];
        }
        else if (flags.length > 0 && flags[0].toString() === "--") {
            return [this.createADD_FlagChown(prefix.length, offset)];
        }
        else if ((copyArgs.length > 0 && docker_1.Util.isInsideRange(position, copyArgs[0].getRange()) && "--chown=".indexOf(prefix) === 0)
            || (flags.length > 0 && "--chown=".indexOf(flags[0].toString()) === 0)) {
            return [this.createADD_FlagChown(prefix.length, offset)];
        }
        return [];
    }
    createCopyProposals(dockerfile, copy, position, offset, prefix) {
        let flag = copy.getFromFlag();
        // is the user in the --from= area
        if (flag && docker_1.Util.isInsideRange(position, flag.getValueRange())) {
            const names = {};
            const items = [];
            let stageIndex = 0;
            // determines if the last build stage was named or not
            let lastNumber = false;
            // get the prefix
            let stagePrefix = this.document.getText().substring(this.document.offsetAt(flag.getValueRange().start), offset).toLowerCase();
            for (let from of dockerfile.getFROMs()) {
                if (copy.isAfter(from)) {
                    const image = from.getImage();
                    let stage = from.getBuildStage();
                    if (stage) {
                        const lowercase = stage.toLowerCase();
                        if (lowercase.indexOf(stagePrefix) === 0 && !names[lowercase]) {
                            names[lowercase] = true;
                            items.push(this.createSourceImageCompletionItem(stage, image, stageIndex, stagePrefix.length, offset));
                        }
                        lastNumber = false;
                    }
                    else if (!names[stageIndex]) {
                        names[stageIndex] = true;
                        items.push(this.createSourceImageCompletionItem(stageIndex.toString(), image, stageIndex, stagePrefix.length, offset));
                        lastNumber = true;
                    }
                    stageIndex++;
                }
                else {
                    break;
                }
            }
            // last build stage was not named, don't suggest it as it is recursive
            if (lastNumber && items.length > 0) {
                items.pop();
            }
            return items;
        }
        const flags = copy.getFlags();
        let copyArgs = copy.getArguments();
        if (copyArgs.length === 0 && copy.getFlags().length === 0) {
            return [this.createCOPY_FlagChown(0, offset), this.createCOPY_FlagFrom(0, offset)];
        }
        else if (copyArgs.length > 0 && docker_1.Util.isInsideRange(position, copyArgs[0].getRange()) && prefix === "-") {
            return [this.createCOPY_FlagChown(prefix.length, offset), this.createCOPY_FlagFrom(prefix.length, offset)];
        }
        else if (flags.length > 0 && flags[0].toString() === "--") {
            return [this.createCOPY_FlagChown(prefix.length, offset), this.createCOPY_FlagFrom(prefix.length, offset)];
        }
        else if ((copyArgs.length > 0 && docker_1.Util.isInsideRange(position, copyArgs[0].getRange()) && "--chown=".indexOf(prefix) === 0)
            || (flags.length > 0 && "--chown=".indexOf(flags[0].toString()) === 0)) {
            return [this.createCOPY_FlagChown(prefix.length, offset)];
        }
        else if ((copyArgs.length > 0 && docker_1.Util.isInsideRange(position, copyArgs[0].getRange()) && "--from=".indexOf(prefix) === 0)
            || (flags.length > 0 && "--from=".indexOf(flags[0].toString()) === 0)) {
            return [this.createCOPY_FlagFrom(prefix.length, offset)];
        }
        return [];
    }
    createFromProposals(from, position, prefix) {
        // checks if the cursor is in the image's tag area
        if (docker_1.Util.isInsideRange(position, from.getImageTagRange())) {
            const index = prefix.indexOf(':');
            const lastIndex = prefix.indexOf(':');
            if (index === lastIndex) {
                prefix = prefix.substring(index + 1);
            }
            else {
                prefix = prefix.substring(index + 1, lastIndex);
            }
            const client = this.dockerRegistryClient;
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                const items = [];
                const tags = yield client.getTags(from.getImageName());
                for (const tag of tags) {
                    if (tag.indexOf(prefix) === 0) {
                        items.push({
                            label: tag,
                            kind: vscode_languageserver_1.CompletionItemKind.Property,
                            insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText,
                        });
                    }
                }
                resolve(items);
            }));
        }
        return [];
    }
    createHealthcheckProposals(offset, prefix) {
        let items = [];
        if (prefix.length < 3 && "CMD".indexOf(prefix.toUpperCase()) === 0) {
            items.push(this.createHEALTHCHECK_CMD_Subcommand(prefix.length, offset));
        }
        if (prefix.length < 4 && "NONE".indexOf(prefix.toUpperCase()) === 0) {
            items.push(this.createHEALTHCHECK_NONE_Subcommand(prefix.length, offset));
        }
        if ("--interval".indexOf(prefix) === 0) {
            items.push(this.createHEALTHCHECK_FlagInterval(prefix.length, offset));
        }
        if ("--retries".indexOf(prefix) === 0) {
            items.push(this.createHEALTHCHECK_FlagRetries(prefix.length, offset));
        }
        if ("--start-period".indexOf(prefix) === 0) {
            items.push(this.createHEALTHCHECK_FlagStartPeriod(prefix.length, offset));
        }
        if ("--timeout".indexOf(prefix) === 0) {
            items.push(this.createHEALTHCHECK_FlagTimeout(prefix.length, offset));
        }
        for (let i = 0; i < items.length; i++) {
            items[i].sortText = i.toString();
        }
        return items;
    }
    /**
     * Walks back in the text buffer to calculate the true prefix of the
     * current text caret offset. This function will handle the
     * Dockerfile escape characters to skip escaped newline characters
     * where applicable.
     *
     * @param buffer the content of the opened file
     * @param offset the current text caret's offset
     * @param escapeCharacter the escape character defined in this Dockerfile
     */
    static calculateTruePrefix(buffer, offset, escapeCharacter) {
        var char = buffer.charAt(offset - 1);
        switch (char) {
            case '\n':
                var escapedPrefix = "";
                for (var i = offset - 1; i >= 0; i--) {
                    if (buffer.charAt(i) === '\n') {
                        if (buffer.charAt(i - 1) === escapeCharacter) {
                            i--;
                        }
                        else if (buffer.charAt(i - 1) === '\r' && buffer.charAt(i - 2) === escapeCharacter) {
                            i = i - 2;
                        }
                        else {
                            break;
                        }
                    }
                    else if (buffer.charAt(i) === ' ' || buffer.charAt(i) === '\t') {
                        break;
                    }
                    else {
                        escapedPrefix = buffer.charAt(i).toUpperCase() + escapedPrefix;
                    }
                }
                if (escapedPrefix !== "") {
                    return escapedPrefix;
                }
                break;
            case '\r':
            case ' ':
            case '\t':
                break;
            default:
                var truePrefix = char;
                for (let i = offset - 2; i >= 0; i--) {
                    char = buffer.charAt(i);
                    if (docker_1.Util.isWhitespace(char)) {
                        break;
                    }
                    else {
                        truePrefix = char + truePrefix;
                    }
                }
                return truePrefix;
        }
        return "";
    }
    createSingleProposals(keyword, prefixLength, offset) {
        switch (keyword) {
            case "ADD":
                return this.createADD(prefixLength, offset, keyword);
            case "CMD":
                return this.createCMD(prefixLength, offset, keyword);
            case "COPY":
                return this.createCOPY(prefixLength, offset, keyword);
            case "ENTRYPOINT":
                return this.createENTRYPOINT(prefixLength, offset, keyword);
            case "ENV":
                return this.createENV(prefixLength, offset, keyword);
            case "EXPOSE":
                return this.createEXPOSE(prefixLength, offset, keyword);
            case "FROM":
                return this.createFROM(prefixLength, offset, keyword);
            case "LABEL":
                return this.createLABEL(prefixLength, offset, keyword);
            case "MAINTAINER":
                return this.createMAINTAINER(prefixLength, offset, keyword);
            case "ONBUILD":
                return this.createONBUILD(prefixLength, offset, keyword);
            case "RUN":
                return this.createRUN(prefixLength, offset, keyword);
            case "SHELL":
                return this.createSHELL(prefixLength, offset, keyword);
            case "STOPSIGNAL":
                return this.createSTOPSIGNAL(prefixLength, offset, keyword);
            case "WORKDIR":
                return this.createWORKDIR(prefixLength, offset, keyword);
            case "VOLUME":
                return this.createVOLUME(prefixLength, offset, keyword);
            case "USER":
                return this.createUSER(prefixLength, offset, keyword);
        }
        throw new Error("Unknown keyword found: " + keyword);
    }
    createADD(prefixLength, offset, markdown) {
        return this.createKeywordCompletionItem("ADD", "ADD source dest", prefixLength, offset, "ADD ${1:source} ${2:dest}", markdown);
    }
    createARG(prefixLength, offset) {
        return this.createKeywordCompletionItem("ARG", "ARG", prefixLength, offset, "ARG", "ARG");
    }
    createARG_NameOnly(prefixLength, offset) {
        return this.createKeywordCompletionItem("ARG", "ARG name", prefixLength, offset, "ARG ${1:name}", "ARG_NameOnly");
    }
    createARG_DefaultValue(prefixLength, offset) {
        return this.createKeywordCompletionItem("ARG", "ARG name=defaultValue", prefixLength, offset, "ARG ${1:name}=${2:defaultValue}", "ARG_DefaultValue");
    }
    createCMD(prefixLength, offset, markdown) {
        return this.createKeywordCompletionItem("CMD", "CMD [ \"executable\" ]", prefixLength, offset, "CMD [ \"${1:executable}\" ]", markdown);
    }
    createCOPY(prefixLength, offset, markdown) {
        return this.createKeywordCompletionItem("COPY", "COPY source dest", prefixLength, offset, "COPY ${1:source} ${2:dest}", markdown);
    }
    createENTRYPOINT(prefixLength, offset, markdown) {
        return this.createKeywordCompletionItem("ENTRYPOINT", "ENTRYPOINT [ \"executable\" ]", prefixLength, offset, "ENTRYPOINT [ \"${1:executable}\" ]", markdown);
    }
    createENV(prefixLength, offset, markdown) {
        return this.createKeywordCompletionItem("ENV", "ENV key=value", prefixLength, offset, "ENV ${1:key}=${2:value}", markdown);
    }
    createEXPOSE(prefixLength, offset, markdown) {
        return this.createKeywordCompletionItem("EXPOSE", "EXPOSE port", prefixLength, offset, "EXPOSE ${1:port}", markdown);
    }
    createFROM(prefixLength, offset, markdown) {
        return this.createKeywordCompletionItem("FROM", "FROM baseImage", prefixLength, offset, "FROM ${1:baseImage}", markdown);
    }
    createHEALTHCHECK_CMD(prefixLength, offset) {
        if (this.snippetSupport) {
            return this.createKeywordCompletionItem("HEALTHCHECK", "HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 CMD [ \"executable\" ]", prefixLength, offset, "HEALTHCHECK --interval=${1:30s} --timeout=${2:30s} --start-period=${3:5s} --retries=${4:3} CMD [ \"${5:executable}\" ]", "HEALTHCHECK_CMD");
        }
        let textEdit = this.createTextEdit(prefixLength, offset, "HEALTHCHECK CMD");
        return {
            data: "HEALTHCHECK_CMD",
            textEdit: textEdit,
            label: "HEALTHCHECK CMD",
            kind: vscode_languageserver_1.CompletionItemKind.Keyword,
            insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText,
        };
    }
    createHEALTHCHECK_CMD_Subcommand(prefixLength, offset) {
        if (this.snippetSupport) {
            return this.createKeywordCompletionItem("CMD", "CMD [ \"executable\" ]", prefixLength, offset, "CMD [ \"${1:executable}\" ]", "HEALTHCHECK_CMD");
        }
        const textEdit = this.createTextEdit(prefixLength, offset, "CMD");
        return {
            data: "HEALTHCHECK_CMD",
            textEdit: textEdit,
            label: "CMD",
            kind: vscode_languageserver_1.CompletionItemKind.Keyword,
            insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText,
        };
    }
    createADD_FlagChown(prefixLength, offset) {
        if (this.snippetSupport) {
            return this.createFlagCompletionItem("--chown=user:group", prefixLength, offset, "--chown=${1:user\:group}", "ADD_FlagChown");
        }
        return this.createFlagCompletionItem("--chown=", prefixLength, offset, "--chown=", "ADD_FlagChown");
    }
    createCOPY_FlagChown(prefixLength, offset) {
        if (this.snippetSupport) {
            return this.createFlagCompletionItem("--chown=user:group", prefixLength, offset, "--chown=${1:user\:group}", "COPY_FlagChown");
        }
        return this.createFlagCompletionItem("--chown=", prefixLength, offset, "--chown=", "COPY_FlagChown");
    }
    createCOPY_FlagFrom(prefixLength, offset) {
        if (this.snippetSupport) {
            return this.createFlagCompletionItem("--from=stage", prefixLength, offset, "--from=${1:stage}", "COPY_FlagFrom");
        }
        return this.createFlagCompletionItem("--from=", prefixLength, offset, "--from=", "COPY_FlagFrom");
    }
    createHEALTHCHECK_FlagInterval(prefixLength, offset) {
        if (this.snippetSupport) {
            return this.createFlagCompletionItem("--interval=30s", prefixLength, offset, "--interval=${1:30s}", "HEALTHCHECK_FlagInterval");
        }
        return this.createFlagCompletionItem("--interval=", prefixLength, offset, "--interval=", "HEALTHCHECK_FlagInterval");
    }
    createHEALTHCHECK_FlagRetries(prefixLength, offset) {
        if (this.snippetSupport) {
            return this.createFlagCompletionItem("--retries=3", prefixLength, offset, "--retries=${1:3}", "HEALTHCHECK_FlagRetries");
        }
        return this.createFlagCompletionItem("--retries=", prefixLength, offset, "--retries=", "HEALTHCHECK_FlagRetries");
    }
    createHEALTHCHECK_FlagStartPeriod(prefixLength, offset) {
        if (this.snippetSupport) {
            return this.createFlagCompletionItem("--start-period=5s", prefixLength, offset, "--start-period=${1:5s}", "HEALTHCHECK_FlagStartPeriod");
        }
        return this.createFlagCompletionItem("--start-period=", prefixLength, offset, "--start-period=", "HEALTHCHECK_FlagStartPeriod");
    }
    createHEALTHCHECK_FlagTimeout(prefixLength, offset) {
        if (this.snippetSupport) {
            return this.createFlagCompletionItem("--timeout=30s", prefixLength, offset, "--timeout=${1:30s}", "HEALTHCHECK_FlagTimeout");
        }
        return this.createFlagCompletionItem("--timeout=", prefixLength, offset, "--timeout=", "HEALTHCHECK_FlagTimeout");
    }
    createHEALTHCHECK_NONE(prefixLength, offset) {
        return this.createPlainTextCompletionItem("HEALTHCHECK NONE", prefixLength, offset, "HEALTHCHECK NONE", "HEALTHCHECK_NONE");
    }
    createHEALTHCHECK_NONE_Subcommand(prefixLength, offset) {
        return this.createPlainTextCompletionItem("NONE", prefixLength, offset, "NONE", "HEALTHCHECK_NONE");
    }
    createLABEL(prefixLength, offset, markdown) {
        return this.createKeywordCompletionItem("LABEL", "LABEL key=\"value\"", prefixLength, offset, "LABEL ${1:key}=\"${2:value}\"", markdown);
    }
    createMAINTAINER(prefixLength, offset, markdown) {
        return this.createKeywordCompletionItem("MAINTAINER", "MAINTAINER name", prefixLength, offset, "MAINTAINER ${1:name}", markdown);
    }
    createONBUILD(prefixLength, offset, markdown) {
        return this.createKeywordCompletionItem("ONBUILD", "ONBUILD INSTRUCTION", prefixLength, offset, "ONBUILD ${1:INSTRUCTION}", markdown);
    }
    createRUN(prefixLength, offset, markdown) {
        return this.createKeywordCompletionItem("RUN", "RUN command", prefixLength, offset, "RUN ${1:command}", markdown);
    }
    createSHELL(prefixLength, offset, markdown) {
        return this.createKeywordCompletionItem("SHELL", "SHELL [ \"executable\" ]", prefixLength, offset, "SHELL [ \"${1:executable}\" ]", markdown);
    }
    createSTOPSIGNAL(prefixLength, offset, markdown) {
        return this.createKeywordCompletionItem("STOPSIGNAL", "STOPSIGNAL signal", prefixLength, offset, "STOPSIGNAL ${1:signal}", markdown);
    }
    createUSER(prefixLength, offset, markdown) {
        return this.createKeywordCompletionItem("USER", "USER daemon", prefixLength, offset, "USER ${1:daemon}", markdown);
    }
    createVOLUME(prefixLength, offset, markdown) {
        return this.createKeywordCompletionItem("VOLUME", "VOLUME [ \"/data\" ]", prefixLength, offset, "VOLUME [ \"${1:/data}\" ]", markdown);
    }
    createWORKDIR(prefixLength, offset, markdown) {
        return this.createKeywordCompletionItem("WORKDIR", "WORKDIR /the/workdir/path", prefixLength, offset, "WORKDIR ${1:/the/workdir/path}", markdown);
    }
    createEscape(prefixLength, offset, markdown) {
        return this.createKeywordCompletionItem(dockerfile_ast_1.Directive.escape, "escape=`", prefixLength, offset, "escape=${1:`}", markdown);
    }
    createKeywordCompletionItem(keyword, label, prefixLength, offset, insertText, markdown) {
        if (!this.snippetSupport) {
            // only inserting the keyword so set the label to the keyword
            label = keyword;
            // just insert the keyword if snippets are not supported by the client
            insertText = keyword;
        }
        let textEdit = this.createTextEdit(prefixLength, offset, insertText);
        return {
            data: markdown,
            textEdit: textEdit,
            label: label,
            kind: vscode_languageserver_1.CompletionItemKind.Keyword,
            insertTextFormat: this.snippetSupport ? vscode_languageserver_1.InsertTextFormat.Snippet : vscode_languageserver_1.InsertTextFormat.PlainText,
        };
    }
    createPlainTextCompletionItem(label, prefixLength, offset, insertText, markdown) {
        let textEdit = this.createTextEdit(prefixLength, offset, insertText);
        return {
            data: markdown,
            textEdit: textEdit,
            label: label,
            kind: vscode_languageserver_1.CompletionItemKind.Keyword,
            insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText,
        };
    }
    createFlagCompletionItem(label, prefixLength, offset, insertText, markdown) {
        let textEdit = this.createTextEdit(prefixLength, offset, insertText);
        return {
            data: markdown,
            textEdit: textEdit,
            label: label,
            kind: vscode_languageserver_1.CompletionItemKind.Field,
            insertTextFormat: this.snippetSupport ? vscode_languageserver_1.InsertTextFormat.Snippet : vscode_languageserver_1.InsertTextFormat.PlainText,
        };
    }
    createSourceImageCompletionItem(label, documentation, buildIndex, prefixLength, offset) {
        return {
            textEdit: this.createTextEdit(prefixLength, offset, label),
            label: label,
            documentation: documentation,
            kind: vscode_languageserver_1.CompletionItemKind.Reference,
            insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText,
            sortText: buildIndex.toString()
        };
    }
    createVariableCompletionItem(text, prefixLength, offset, brace, documentation) {
        text = brace ? "${" + text + '}' : '$' + text;
        return {
            textEdit: this.createTextEdit(prefixLength, offset, text),
            label: text,
            kind: vscode_languageserver_1.CompletionItemKind.Variable,
            insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText,
            documentation: documentation
        };
    }
    createTextEdit(prefixLength, offset, content) {
        if (prefixLength === 0) {
            return vscode_languageserver_1.TextEdit.insert(this.document.positionAt(offset), content);
        }
        return vscode_languageserver_1.TextEdit.replace(vscode_languageserver_1.Range.create(this.document.positionAt(offset - prefixLength), this.document.positionAt(offset)), content);
    }
}
exports.DockerAssist = DockerAssist;
